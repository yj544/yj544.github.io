---
title: "equals를 재정의할 때는 반드시 hashCode도 재정의하라"
categories:
  - java
tags:
  - java
  - effectivejava
---
#### equals를 재정의할 때는 반드시 hashCode도 재정의하라

##### Java HashCode
hashCode 함수는 equals, toString 함수와 마찬가지로 Object 클래스에 포함되어 있다.

```java
    public native int hashCode();
```

Object의 hashCode에서 말하는 hashCode 함수의 규약은 다음과 같다.
- equals 함수에서 비교에 사용된 객체가 변경되지 않았다면 Java 어플리케이션이 실행되는 동안 같은 객체에 대해서 여러 번 hashCode를 호출해도 같은 정수를 반환해야 한다.
- equals 함수가 같다고 판단한 두 객체는 hashCode의 값도 같아야 한다.
- equals 함수가 다르다고 판단한 두 객체의 hashCode의 값은 반드시 다를 필요는 없다.
-1881759168,-1881759167,-1881759168
String 클래스의 hashCode 구현부를 확인해보면 다음과 같다.
```java
    private int hash; // Default to 0

    public int hashCode() {
        int h = hash;
        if (h == 0 && value.length > 0) {
            char val[] = value;

            for (int i = 0; i < value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }
```
hash가 구해졌다면 해당 값을 리턴하기 때문에 hash 에 대한 값이 변할 일이 없고 ``(조건1)`` 배열에 들어간 데이터를 기반으로 hashCode를 만들기 때문에 equals가 참인 객체는 항상 hash 값이 같을 것이다 ``(조건2)`` 마찬가지로 equals가 거짓이어도 hash 값이 같을 가능성이 있다 ``(조건3)``

##### Java HashMap
그러면 어떤 이유로 equals와 hashCode는 함께 오버라이딩해야 하는 걸까?
예시로 사용할 Item 클래스는 이름과 개수를 멤버변수로 가지며 equals 함수만 오버라이딩 했다. 
```java 
public class Item {
    String name;
    int count;

    public Item(){};

    public Item(String name, int count){
        this.name = name;
        this.count = count;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Item item = (Item) o;
        return count == item.count && Objects.equals(name, item.name);
    }
}
```

객체의 이름과 개수가 같은 경우 equals는 같다고 판단한다. 

```java 
    Item pencil1 = new Item("pencil", 3);
    Item pencil2 = new Item("pencil", 3);
    Item eraser = new Item("eraser", 5);

    if(pencil1.equals(pencil2)){
        //참임
    }

    if(pencil1.equals(eraser)){
        //거짓임
    }
```

이 객체를 HashMap에 넣어보자. 
```java 
    Item pencil1 = new Item("pencil", 3);
    Item pencil2 = new Item("pencil", 3);
    Item eraser = new Item("eraser", 5);

    HashMap<Item, String> itemHashMap = new HashMap<>();
    itemHashMap.put(pencil, "table");
    itemHashMap.put(pencil2, "pencilcase");
    itemHashMap.put(eraser, "desk");
    
    System.out.println("itemHashMap Count: " + itemHashMap.size()); //1: itemHashMap Count: 3

    System.out.println("found item: " + itemHashMap.get(pencil1)); //2: found item: table
    System.out.println("found item: " + itemHashMap.get(new Item("pencil", 3))); //3: found item: null
```
hashMap은 key 값이 중복될 수 없기 때문에 equals가 참이라고 판단했던 pencil1과 pencil2는 동시에 들어갈 수 없고, 따라서 hashMap의 사이즈는 2가 되어야 한다. 하지만 값은 3이다.``1:``

또한 hashMap에서 pencil1과 같은 값을 가지는 객체를 통해 value를 얻으려고 했으나 null을 얻었다. ``3:``

이런 문제는 모두 Item 클래스에 hashCode 함수가 오버라이딩되지 않았기 때문에 발생한다. 

HashMap의 put 함수 구현부는 다음과 같다. 
```java
    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }   
```

key를 가지고 hash를 도출하는데, 여기에서 key의 hashCode를 사용한다. 
```java
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }    
```

putVal에서는 (table의 크기-1)과 hash의 & 연산으로 나온 인덱스에 값이 없다면 해당 위치에 데이터를 추가한다. 
```java
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node<K,V> e; K k;
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size > threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
```
hashCode 함수를 오버라이딩하지 않은 경우 Object의 hashCode가 정수를 리턴하며, 비록 equals에서는 같다고 판단한 객체일지라도 Object의 hashCode는 전혀 다른 정수를 리턴한다. 따라서 HashMap에 같은(같아 보이는) Key가 두 개 추가되는 문제가 발생한다. 

또한 get 구현부는 아래와 같다. 
```java
    public V get(Object key) {
        Node<K,V> e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }

    final Node<K,V> getNode(int hash, Object key) {
        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
        if ((tab = table) != null && (n = tab.length) > 0 &&
            (first = tab[(n - 1) & hash]) != null) {
            if (first.hash == hash && // always check first node
                ((k = first.key) == key || (key != null && key.equals(k))))
                return first;
            if ((e = first.next) != null) {
                if (first instanceof TreeNode)
                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);
                do {
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        return null;
    }    
```
hash가 다른 객체를 넣었으니 (first = tab[(n - 1) & hash]) != null) 에서 이미 다른 인덱스를 찾게 되고 당연히 해당 인덱스에 값이 없어서 null을 리턴하게 되는 것이다. 